@tailwind base;
@tailwind components;
@tailwind utilities;


html, body{
    height: 100%;
    background-color: "#222831";
    font-family: "Kaisei Decol";
    color: "#FFD369";
}



/* const ListenKey = (
  render,
  RacketRight,
  RacketLeft,
  Ball,
  RacketHeight,
  Body,
  ballSpeed,
  isStart,
  setIsStart
) => {
  let keys = {};

  // Listen to keydown and keyup events
  window.addEventListener("keydown", function (event) {
    keys[event.code] = true;

    // Start the game when spacebar is pressed
    if (event.code === "Space" && !isStart) {
      setIsStart(true);
      Body.setVelocity(Ball, { x: 12, y: ballSpeed });
    }
  });

  window.addEventListener("keyup", function (event) {
    keys[event.code] = false;
  });

  function RunMovement() {
    let racketSpeed = 12;
    const canvasHeight = render.options.height;
    let drY = 0;
    let dlY = 0;

    if (keys["ArrowUp"]) {
      drY -= racketSpeed;
      if (RacketRight.position.y - RacketHeight / 2 > 0)
        Matter.Body.translate(RacketRight, { x: 0, y: drY });
    }

    if (keys["ArrowDown"]) {
      drY += racketSpeed;
      if (RacketRight.position.y + RacketHeight / 2 < canvasHeight)
        Matter.Body.translate(RacketRight, { x: 0, y: drY });
    }

    if (keys["KeyW"]) {
      dlY -= racketSpeed;
      if (RacketLeft.position.y - RacketHeight / 2 > 0)
        Matter.Body.translate(RacketLeft, { x: 0, y: dlY });
    }

    if (keys["KeyS"]) {
      dlY += racketSpeed;
      if (RacketLeft.position.y + RacketHeight / 2 < canvasHeight)
        Matter.Body.translate(RacketLeft, { x: 0, y: dlY });
    }

    // Continue running the function to detect key presses
    requestAnimationFrame(RunMovement);
  }

  RunMovement();
};

const Collision = (
  Events,
  Body,
  engine,
  Ball,
  setScoreA,
  setScoreB,
  initialBallPos,
  setIsStart
) => {
  const BallSound = new Audio("./BallSound.mp3");
  const Fail = new Audio("./Fail.mp3");

  Events.on(engine, "collisionStart", (event) => {
    const pairs = event.pairs;
    pairs.forEach((pair) => {
      const { bodyA, bodyB } = pair;
      const ball = Ball;
      let bodyC = 0;

      if (bodyA === ball) bodyC = bodyB;
      else if (bodyB === ball) bodyC = bodyA;

      if (bodyC.label === "left") {
        setScoreA((prevNumber) => prevNumber + 1);
        setIsStart(false);
        Fail.play();
        Body.setVelocity(Ball, { x: 0, y: 0 });
        Body.setPosition(Ball, initialBallPos);
      } else if (bodyC.label === "right") {
        setScoreB((prevNumber) => prevNumber + 1);
        setIsStart(false);
        Fail.play();
        Body.setVelocity(Ball, { x: 0, y: 0 });
        Body.setPosition(Ball, initialBallPos);
      } else if (bodyC.label === "RacketR" || bodyC.label === "RacketL") {
        BallSound.play();
      }
    });
  });
};

export function Game() {
  const canva = useRef(null);
  const [scoreA, setScoreA] = useState(0);
  const [scoreB, setScoreB] = useState(0);
  const [isStart, setIsStart] = useState(false);

  useEffect(() => {
    let ballSpeed = 3;
    let Width = window.innerWidth * 0.7;
    let Height = window.innerHeight * 0.6;
    const RacketWidth = 25;
    const RacketHeight = 110;
    const initialBallPos = { x: Width / 2, y: Height / 2 };

    const Engine = Matter.Engine;
    const Render = Matter.Render;
    const Bodies = Matter.Bodies;
    const World = Matter.World;
    const Runner = Matter.Runner;
    const Events = Matter.Events;
    const Body = Matter.Body;

    const engine = Engine.create();
    const runner = Runner.create();
    const render = Render.create({
      engine: engine,
      canvas: canva.current,
      options: {
        width: Width,
        height: Height,
        wireframes: false,
        background: "#393E46",
      },
    });

    function resizeCanvas() {
      let newWidth = window.innerWidth * 0.7;
      let newHeight = window.innerHeight * 0.6;

      render.canvas.width = newWidth;
      render.canvas.height = newHeight;

      if (walls) {
        Matter.Body.setPosition(walls[0], { x: newWidth / 2, y: 0 });
        Matter.Body.setPosition(walls[1], { x: newWidth / 2, y: newHeight });
        Matter.Body.setPosition(walls[2], { x: 0, y: newHeight / 2 });
        Matter.Body.setPosition(walls[3], { x: newWidth, y: newHeight / 2 });

        Matter.Body.scale(walls[0], newWidth / Width, 1);
        Matter.Body.scale(walls[1], newWidth / Width, 1);
        Matter.Body.scale(walls[2], 1, newHeight / Height);
        Matter.Body.scale(walls[3], 1, newHeight / Height);
      }
      if (RacketLeft && RacketRight) {
        Matter.Body.setPosition(RacketLeft, { x: 15, y: newHeight / 2 });
        Matter.Body.setPosition(RacketRight, {
          x: newWidth - 15,
          y: newHeight / 2,
        });

        Matter.Body.scale(RacketLeft, 1, newHeight / Height);
        Matter.Body.scale(RacketRight, 1, newHeight / Height);
      }

      if (Fil) {
        Matter.Body.setPosition(Fil, { x: newWidth / 2, y: newHeight / 2 });
        Matter.Body.scale(Fil, newWidth / Width, newHeight / Height);
      }
      Matter.Body.setPosition(Ball, { x: newWidth / 2, y: newHeight / 2 });

      Width = newWidth;
      Height = newHeight;
    }

    window.addEventListener("resize", resizeCanvas);

    engine.world.gravity.y = 0;
    engine.timing.timeScale = 1;

    const { RacketLeft, RacketRight } = CreatRackets(
      Bodies,
      RacketWidth,
      RacketHeight,
      render
    );

    const { Ball, Fil, walls } = CreateBallFillWall(
      Bodies,
      render,
      initialBallPos,
      0
    );

    World.add(engine.world, [RacketRight, RacketLeft, ...walls, Fil, Ball]);

    Runner.run(runner, engine);
    Render.run(render);

    ListenKey(
      render,
      RacketRight,
      RacketLeft,
      Ball,
      RacketHeight,
      Body,
      ballSpeed,
      isStart,
      setIsStart
    );

    Collision(
      Events,
      Body,
      engine,
      Ball,
      setScoreA,
      setScoreB,
      initialBallPos,
      setIsStart
    );

    resizeCanvas();

    return () => {
      Matter.Render.stop(render);
      Matter.Engine.clear(engine);
      Matter.World.clear(engine.world);
    };
  }, [isStart]);

  return (
    <div
      className=""
      style={{ height: "100%", backgroundColor: "#222831", color: "#FFD369" }}
    >
      <div className="flex text-7x justify-center ">
        <h1 className="text-7xl mr-52" style={{ color: "#FFD369" }}>
          {scoreA}
        </h1>
        <span className="font-extralight text-5xl flex items-center">VS</span>
        <h1 className="text-7xl ml-52" style={{ color: "#FFD369" }}>
          {scoreB}
        </h1>
      </div>
      <div>
        <canvas className="block mx-auto z-3 text-white" ref={canva} />
        {!isStart && (
          <h1 className="flex justify-center pt-10 text-4xl z-50">
            Press Space to START
          </h1>
        )}
      </div>
    </div>
  );
} */


